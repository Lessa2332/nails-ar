<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Christmas Nail AR Try-On</title>
  <link rel="icon" type="image/png" href="image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOxAAADsQBlSsOGwAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAJDSURBVHic7ZddbJNXFMc/Z87XtqS0pS1tKaUspS2lQIGPYQtsgCzZkLAhE8TExMRoTMTEi4kvXngxEy98MXHhZV+8mZgYMzExMTHZECMbA9kYjLEBxRQKpaV0fWvb2n7t+3pxU7qBdKUf1CXZf7r3nnvOuef+/++551zLNE3TJIQQQgghhBBCCLFFlq0OYDM0zUQFqAaKgXygEMgGXCZgAA1AHdBk61rj9Zs2EID/AS6gCigCsoA0wIq/2AYGgW6gFbgPdJmmOWQ7ARoM4BqA4wAeBfKADEAH+oEWoM2yLE2zJQANBnDdBLYDhwEn0ATcN03T2MjvNxnADQO4CeBJIA9oAW6bptm/GZFuOIBrBrANOAoUA3eA26ZpDr3q720kgGsGMAc4AeQDN4Hbpmn2bkbMaw7gmgHkAmeBUqANuGqaZvdWJfSqALYBzwBlQBdw2TTNga1O9GUAbAeeA8qBAeCSaZrNW5XkywC4wDngCNANfG+a5t3NTvRlAFKAF4DDQCfwuWma9zY70b8L4DrgA04DA8Cnpml2b0aiqwbgOvA6cAboAN42TbN9KxJdNYB9DfADkAZ8YJpmw1YkuqoAbAOfAUeBAeBD0zTvbkWi6wbgBr4DTgDvAXPAKdM0P4tFsBsGIAJcAaqBT4E5oMY0za9jEeyGAQgA3wLZwAtAH/AqaZpfxiLYDQMgAFwGcoAXgSHgBdM0v4hFsJsCwA58BRwC3gDmgKdM0/wmFsFuCoAb+AY4BLwNzAOnTNP8PhbBbhoAG/ARkA28DAwCZ0zT/CEWwW46ABvwDpANXACmgWemaX4Xi2A3HYAD+A7IAV4DhoCzpmn+EIsgtxSAHfgSyAH+DQwDp03TvBKLIB8IgB34CMgGLgJTwFOmaf4Si2AfCIAI8ANQAfwHMAycMU3z11gE90AAOICfgELg38AwcMo0zf/9VcAHCsAB/AQcAN4GZoFTpmn+EYsgHhiAHfgR2Ae8AUwBz5im+XssgnhgAOzAn0Ax8CZgAKdM02yIRQCPBMAOXAWKgTeAMeC0aZr1sQjikQDYgRuADbwGDAKnTNOsj0UQjwwAAOzATaAQeB0YAU6apvlHLILYEgAO4BZgA68AXcAp0zSbYhHElgBwAHcAG3gR6ASOmaZZF4sgthSAHbgHZANngXbgiGma9bEIYssA2IFeIBs4DTQDB03TbI1FELcMgAPoA3KAE0AzsNc0zftbHcSWA3AAg0AeUAs0AjtM0xzY6iC2HIADGAHygVqgAdhmmubQVgex5QAcwAiQD1QD9cB20zSHtzqIOAFgB0aBfKAKqAO2mqY5utVBxBGAHRgD8oEqoBbYappm31YHEVcADmAcyAe2ALXAFtM0e7Y6iLgC4AAGgXygEqgGKkzT7NzqIOIOwA4MAvnAHqAKKDVNs2OrA4g7AAfgB/YClUAFUGqaZvtWBxD3AGxgCMgHioDdwHbTNJviHkASAAwAOcBOoAzYappmU9wDSAKAASAX2AOUA1tM07wf9wCSAWAAWcBuoBTYbJpmfdwDSAGAATiBXUAZsMk0zc9SAPwXAJcBpQAAAABJRU5ErkJggg==">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#ff4757">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4, #fad0c4);
      overflow: hidden;
      font-family: 'Arial', 'Segoe UI', system-ui, sans-serif;
      color: white;
    }
    #video, #photoInput, #canvas, #confettiCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #photoInput { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }
    #confettiCanvas { z-index: 60; pointer-events: none; }
    .control-btn {
      position: fixed;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 255, 255, 0.4);
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }
    .control-btn:hover { transform: scale(1.15); background: rgba(255, 255, 255, 0.3); }
    #langBtn { top: 20px; right: 20px; font-weight: bold; font-size: 16px; }
    #soundBtn { top: 20px; left: 20px; }
    #uploadBtn { top: 80px; left: 20px; }
    #photoUploadBtn { top: 140px; left: 20px; }
    #authorBtn {
      position: fixed;
      top: 78px;
      right: 20px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      border: 3px solid #ffd700;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(255, 71, 87, 0.5), 0 0 0 4px #ffd700;
      animation: pulse-glow 2s infinite;
    }
    #authorBtn:hover {
      transform: scale(1.2) rotate(10deg);
      background: linear-gradient(135deg, #ff4757, #ff6b6b);
      box-shadow: 0 8px 25px rgba(255, 71, 87, 0.7), 0 0 0 6px #ffd700;
    }
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 6px 20px rgba(255, 71, 87, 0.5), 0 0 0 4px #ffd700; }
      50% { box-shadow: 0 8px 30px rgba(255, 71, 87, 0.7), 0 0 0 6px #ffd700; }
    }
    #modeControls {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(20px);
      padding: 6px 12px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      max-width: calc(100% - 120px);
    }
    .mode-btn {
      padding: 8px 16px;
      border-radius: 20px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      white-space: nowrap;
    }
    .mode-btn:hover { transform: translateY(-2px); }
    .mode-btn.active { background: linear-gradient(135deg, #ff6b6b, #ff4757); animation: pulse 2s infinite; }
    #designPicker {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(20px);
      padding: 15px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      max-width: 90vw;
      overflow-x: auto;
      scrollbar-width: none;
    }
    #designPicker::-webkit-scrollbar { display: none; }
    .design-btn {
      width: 60px;
      height: 90px;
      border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      object-fit: contain;
      background: transparent;
      cursor: pointer;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }
    .design-btn:hover { transform: scale(1.1); border-color: rgba(255, 255, 255, 0.6); }
    .design-btn.selected { transform: scale(1.15); border-color: #ffd700; box-shadow: 0 0 0 3px #ffd700; }
    #maskPicker {
      position: fixed;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(20px);
      padding: 15px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      max-width: 90vw;
      overflow-x: auto;
      scrollbar-width: none;
    }
    #maskPicker::-webkit-scrollbar { display: none; }
    .mask-btn {
      width: 60px;
      height: 60px;
      border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      background: transparent;
      cursor: pointer;
      transition: all 0.3s ease;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 12px;
      text-align: center;
    }
    .mask-btn:hover { transform: scale(1.1); border-color: rgba(255, 255, 255, 0.6); }
    .mask-btn.selected { transform: scale(1.15); border-color: #ffd700; box-shadow: 0 0 0 3px #ffd700; }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #ff6b6b;
      font-size: clamp(18px, 4vw, 24px);
      text-align: center;
      padding: 20px;
      gap: 20px;
    }
    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 107, 107, 0.3);
      border-top: 4px solid #ff6b6b;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    #loading p {
      color: #fff;
      font-size: clamp(14px, 3vw, 18px);
      max-width: 300px;
      line-height: 1.4;
    }
    .indicator {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
      align-items: center;
      gap: 8px;
      z-index: 99;
      font-size: 14px;
    }
    #cameraIndicator { top: 20px; }
    #handIndicator { top: 160px; }
    .indicator.show { display: flex; animation: slideDown 0.3s ease; }
    #errorRetry {
      margin-top: 20px;
      padding: 12px 24px;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      border: none;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 25px;
      transition: all 0.3s ease;
    }
    #errorRetry:hover { transform: translateY(-2px); }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    @media (max-width: 768px) {
      .control-btn { width: 44px; height: 44px; font-size: 17px; }
      #authorBtn { width: 50px; height: 50px; top: 74px; font-size: 22px; }
      #modeControls { top: 18px; gap: 8px; padding: 5px 10px; }
      .mode-btn { padding: 7px 14px; font-size: 12px; }
      .design-btn { width: 50px; height: 75px; }
      .mask-btn { width: 50px; height: 50px; font-size: 10px; }
      #maskPicker { bottom: 140px; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div id="loadingText">Loading Christmas Nail Magic...</div>
    <p>Please allow camera access</p>
  </div>
  <video id="video" playsinline muted></video>
  <img id="photoInput" alt="Hand photo for calibration">
  <canvas id="canvas"></canvas>
  <canvas id="confettiCanvas"></canvas>
  <input type="file" id="designUpload" accept="image/*" multiple style="display: none;">
  <input type="file" id="photoUpload" accept="image/*" style="display: none;">
  <button id="langBtn" class="control-btn" aria-label="Switch language">UK</button>
  <button id="soundBtn" class="control-btn" aria-label="Toggle sound">Sound</button>
  <button id="uploadBtn" class="control-btn" aria-label="Upload custom designs from gallery">üìÅ</button>
  <button id="photoUploadBtn" class="control-btn" aria-label="Upload hand photo for calibration">üì∏</button>
  <a href="https://smartlessa.etsy.com" target="_blank" rel="noopener" id="authorBtn" aria-label="Author: smartlessa.etsy.com">
    Author
  </a>
  <div id="modeControls">
    <button class="mode-btn active" id="applyAllBtn" aria-label="Apply to all fingers">All Fingers</button>
    <button class="mode-btn" id="selectFingerBtn" aria-label="Select finger">Select Finger</button>
  </div>
  <div id="maskPicker"></div>
  <div id="designPicker"></div>
  <div id="cameraIndicator" class="indicator">
    <span>Camera</span>
    <span>Camera Active</span>
  </div>
  <div id="handIndicator" class="indicator">
    <span>Hand</span>
    <span>Show your hand</span>
  </div>
  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>
  <script type="module">
    // ‚Äî‚Äî‚Äî PWA: Service Worker Registration ‚Äî‚Äî‚Äî
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js').catch(console.warn);
      });
    }

    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    // ... (–≤–µ—Å—å —Ç–≤—ñ–π –∫–æ–¥ –±–µ–∑ –∑–º—ñ–Ω, –æ–∫—Ä—ñ–º 2 –º—ñ—Å—Ü—å –Ω–∏–∂—á–µ)

    const CONFIG = {
      SMOOTHING_FACTOR: 0.7,
      HAND_NOT_DETECTED_THRESHOLD: 10,
      NAIL_SCALE_FACTORS: {
        thumb: 0.35,
        index: 0.45,
        middle: 0.47,
        ring: 0.45,
        pinky: 0.35
      },
      NAIL_ASPECT_RATIOS: {
        thumb: 0.75,
        index: 0.80,
        middle: 0.82,
        ring: 0.80,
        pinky: 0.85
      },
      MIN_SIZE: 25,
      MAX_SIZE: 85,
      WRIST_DISTANCE_REF: 0.1,
      SCALE_SENSITIVITY: 1.8,
      MAX_SCALE_FACTOR: 2.0,
      MIN_SCALE_FACTOR: 0.6,
      TARGET_FPS: 30
    };
    const FINGER_INDICES = {
      thumb: { tip: 4, mcp: 2, pip: 3, ip: 3 },
      index: { tip: 8, mcp: 5, pip: 6, dip: 7 },
      middle: { tip: 12, mcp: 9, pip: 10, dip: 11 },
      ring: { tip: 16, mcp: 13, pip: 14, dip: 15 },
      pinky: { tip: 20, mcp: 17, pip: 18, dip: 19 }
    };
    const FINGER_KEYS = Object.keys(FINGER_INDICES);
    const translations = {
      en: {
        title: "Christmas Nail AR Try-On",
        loading: "Loading Christmas Nail Magic...",
        cameraPrompt: "Please allow camera access",
        allFingers: "All Fingers",
        pickFinger: "Select Finger",
        cameraError: "Camera access denied.<br>Try Chrome or Safari.",
        arError: "AR failed to load.<br>Refresh page.",
        retry: "Retry",
        cameraActive: "Camera Active",
        handNotDetected: "Show your hand",
        photoCalib: "Upload a clear photo of your hand for better fitting"
      },
      uk: {
        title: "–†—ñ–∑–¥–≤—è–Ω–∏–π –º–∞–Ω—ñ–∫—é—Ä!",
        loading: "–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –†—ñ–∑–¥–≤—è–Ω–æ–≥–æ –º–∞–Ω—ñ–∫—é—Ä—É...",
        cameraPrompt: "–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏",
        allFingers: "–£—Å—ñ –ø–∞–ª—å—Ü—ñ",
        pickFinger: "–û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å",
        cameraError: "–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏.<br>–°–ø—Ä–æ–±—É–π—Ç–µ Chrome –∞–±–æ Safari.",
        arError: "–ü–æ–º–∏–ª–∫–∞ AR.<br>–û–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É.",
        retry: "–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏",
        cameraActive: "–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        handNotDetected: "–ü–æ–∫–∞–∂–∏ —Ä—É–∫—É",
        photoCalib: "–ó–∞–≤–∞–Ω—Ç–∞–∂ —á—ñ—Ç–∫–µ —Ñ–æ—Ç–æ —Ä—É–∫–∏ –¥–ª—è –∫—Ä–∞—â–æ—ó –ø—Ä–∏–º—ñ—Ä–∫–∏"
      }
    };
    const state = {
      currentLang: 'en',
      currentDesign: "1",
      currentMask: "none",
      isApplyAll: true,
      selectedFingerIndex: -1,
      isMuted: false,
      lastLandmarks: null,
      smoothedLandmarks: null,
      handNotDetectedCount: 0,
      animationFrameId: null,
      palmOrientation: { x: 0, y: 0 },
      currentHandSize: 1.0,
      wristDistance: 0,
      rainbowTime: 0,
      isAudioUnlocked: false,
      customDesigns: [],
      frameTimestamp: 0,
      isPhotoMode: false,
      lastRenderTime: 0,
      detectedHands: []
    };
    const elements = {
      video: document.getElementById("video"),
      photoInput: document.getElementById("photoInput"),
      canvas: document.getElementById("canvas"),
      confettiCanvas: document.getElementById("confettiCanvas"),
      designUpload: document.getElementById("designUpload"),
      photoUpload: document.getElementById("photoUpload"),
      loading: document.getElementById("loading"),
      loadingText: document.getElementById("loadingText"),
      langBtn: document.getElementById("langBtn"),
      soundBtn: document.getElementById("soundBtn"),
      uploadBtn: document.getElementById("uploadBtn"),
      photoUploadBtn: document.getElementById("photoUploadBtn"),
      authorBtn: document.getElementById("authorBtn"),
      applyAllBtn: document.getElementById("applyAllBtn"),
      selectFingerBtn: document.getElementById("selectFingerBtn"),
      designPicker: document.getElementById("designPicker"),
      maskPicker: document.getElementById("maskPicker"),
      cameraIndicator: document.getElementById("cameraIndicator"),
      handIndicator: document.getElementById("handIndicator")
    };
    const confettiCtx = elements.confettiCanvas.getContext("2d");
    let confetti = [];
    function resizeCanvases() {
      elements.confettiCanvas.width = window.innerWidth;
      elements.confettiCanvas.height = window.innerHeight;
    }
    resizeCanvases();
    window.addEventListener('resize', resizeCanvases);
    const audio = {
      bgMusic: new Audio('audio/bg-music.mp3')
    };
    audio.bgMusic.loop = true;
    audio.bgMusic.volume = 0.4;
    const DESIGNS = ["1", "2", "3"];
    const MASKS = [
      { id: "none", name: "None" },
      { id: "square", name: "Square" },
      { id: "squared_oval", name: "Squared Oval" },
      { id: "oval", name: "Oval" },
      { id: "rounded", name: "Rounded" },
      { id: "almond", name: "Almond" },
      { id: "mountain_peak", name: "Mountain Peak" },
      { id: "stiletto", name: "Stiletto" },
      { id: "ballerina", name: "Ballerina" },
      { id: "edge", name: "Edge" },
      { id: "lipstick", name: "Lipstick" },
      { id: "flare", name: "Flare" },
      { id: "arrow_head", name: "Arrow Head" }
    ];
    const nailTextures = {};
    let scene, camera, renderer;
    const nails = {};
    let handLandmarker;
    const NAIL_SHADER = {
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        void main() {
          vUv = uv;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vViewPosition = -mvPosition.xyz;
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform sampler2D map;
        uniform float time;
        uniform float shineIntensity;
        uniform int maskType;
        uniform float fingerAngle;
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        vec3 rainbow(float t) {
          return vec3(
            0.5 + 0.5 * sin(t),
            0.5 + 0.5 * sin(t + 2.0),
            0.5 + 0.5 * sin(t + 4.0)
          );
        }
        float ovalMask(vec2 uv, float angle) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
          d = rot * d;
          float r = 0.5;
          float ellipse = (d.x * d.x) / (r * r) + (d.y * d.y) / (r * r * 0.7);
          return 1.0 - smoothstep(0.99, 1.0, ellipse);
        }
        float roundedSquareMask(vec2 uv, float angle) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = abs(uv - center);
          float radius = 0.1;
          mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
          d = rot * d;
          vec2 q = d - vec2(0.5 - radius);
          float dist = length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - radius;
          return 1.0 - smoothstep(0.0, 0.01, dist);
        }
        float almondMask(vec2 uv, float angle) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
          d = rot * d;
          float dx = d.x * 1.5;
          float dy = d.y * 1.2;
          float r = sqrt(dx*dx + dy*dy);
          float shapeAngle = atan(dy, dx) + angle;
          float shape = 0.5 + 0.3 * cos(4.0 * shapeAngle);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float gelEffect(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          float dist = distance(uv, center);
          float shine = 0.8 + 0.2 * sin(time * 3.0 + dist * 10.0);
          return shine;
        }
        float squareMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = abs(uv - center);
          float size = 0.45;
          float edge = 0.05;
          if (d.x > size || d.y > size) return 0.0;
          if (d.x < size - edge && d.y < size - edge) return 1.0;
          return 1.0 - smoothstep(size - edge, size, max(d.x, d.y));
        }
        float squovalMask(vec2 uv, float angle) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
          d = rot * d;
          float dx = d.x * 1.2;
          float dy = d.y * 0.8;
          float r = sqrt(dx*dx + dy*dy);
          return 1.0 - smoothstep(0.45, 0.5, r);
        }
        float roundedMask(vec2 uv, float angle) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          mat2 rot = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
          d = rot * d;
          float r = length(d);
          return 1.0 - smoothstep(0.45, 0.5, r);
        }
        void main() {
          vec4 texColor = texture2D(map, vUv);
          if (texColor.a < 0.1) discard;
          vec3 color = texColor.rgb;
          float mask = 1.0;
          if (maskType == 1) {
            mask = squareMask(vUv);
          } else if (maskType == 2) {
            mask = squovalMask(vUv, fingerAngle);
          } else if (maskType == 3) {
            mask = ovalMask(vUv, fingerAngle);
          } else if (maskType == 4) {
            mask = roundedMask(vUv, fingerAngle);
          } else if (maskType == 5) {
            mask = almondMask(vUv, fingerAngle);
          } else if (maskType == 13) {
            float gel = gelEffect(vUv);
            color *= gel;
          }
          float shine = smoothstep(0.3, 0.7, vUv.y + sin(vUv.y * 8.0 - time * 1.5) * 0.1);
          shine = pow(shine, 2.0) * 0.5;
          vec3 highlight = rainbow(time * 3.0) * shine * shineIntensity;
          float shadow = smoothstep(0.0, 0.25, vUv.y);
          color *= (1.0 - shadow * 0.25);
          color = color + highlight;
          gl_FragColor = vec4(color, texColor.a * mask);
        }
      `
    };
    class ConfettiParticle {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = Math.random() * -15 - 5;
        this.size = Math.random() * 6 + 4;
        this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
        this.life = 1.0;
        this.gravity = 0.4;
        this.rotation = Math.random() * Math.PI * 2;
        this.spin = (Math.random() - 0.5) * 0.3;
      }
      update() {
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.015;
        this.rotation += this.spin;
      }
      draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
      }
    }
    class NailARApplication {
      constructor() { this.init(); }
      async init() {
        try {
          this.setupEventListeners();
          await this.setupCamera();
          await this.initWebGL();
          await this.setupHandTracking();
          await this.loadResources();
          this.setupAudio();
          this.updateUI();
          this.hideLoading();
          this.startRenderLoop();
          this.unlockAudio();
        } catch (error) {
          this.handleError(error);
        }
      }
      unlockAudio() {
        const unlock = () => {
          if (state.isAudioUnlocked) return;
          state.isAudioUnlocked = true;
          if (!state.isMuted) {
            audio.bgMusic.play().catch(() => {});
          }
          document.removeEventListener('click', unlock);
          document.removeEventListener('touchstart', unlock);
        };
        document.addEventListener('click', unlock, { once: true });
        document.addEventListener('touchstart', unlock, { once: true });
      }
      setupAudio() {}
      toggleSound() {
        state.isMuted = !state.isMuted;
        if (state.isMuted) {
          audio.bgMusic.pause();
        } else if (state.isAudioUnlocked) {
          audio.bgMusic.play().catch(() => {});
        }
        this.updateSoundButton();
      }
      setupEventListeners() {
        elements.langBtn.addEventListener('click', () => this.toggleLanguage());
        elements.soundBtn.addEventListener('click', () => this.toggleSound());
        elements.uploadBtn.addEventListener('click', () => this.uploadDesigns());
        elements.designUpload.addEventListener('change', (e) => this.handleDesignUpload(e));
        elements.photoUploadBtn.addEventListener('click', () => this.uploadHandPhoto());
        elements.photoUpload.addEventListener('change', (e) => this.handleHandPhotoUpload(e));
        elements.applyAllBtn.addEventListener('click', () => this.setApplyAllMode());
        elements.selectFingerBtn.addEventListener('click', () => this.setSelectFingerMode());
        elements.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        elements.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.handleCanvasClick(e);
        });
        window.addEventListener('resize', () => {
          this.handleResize();
          resizeCanvases();
        });
        window.addEventListener('beforeunload', () => this.cleanup());
      }
      async setupCamera() {
        try {
          const constraints = { video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } } };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          elements.video.srcObject = stream;
          await new Promise(r => { elements.video.onloadedmetadata = () => { elements.video.play(); r(); }; });
          this.showCameraIndicator();
        } catch (error) {
          console.error('Camera setup failed:', error);
          throw new Error('CAMERA_ERROR');
        }
      }
      async initWebGL() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(
          -window.innerWidth / 2,
          window.innerWidth / 2,
          window.innerHeight / 2,
          -window.innerHeight / 2,
          0.1,
          1000
        );
        camera.position.z = 10;
        renderer = new THREE.WebGLRenderer({
          canvas: elements.canvas,
          alpha: true,
          antialias: true,
          powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.createNails();
      }
      createNails() {
        const shaderMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: null },
            time: { value: 0 },
            shineIntensity: { value: 1.0 },
            maskType: { value: 0 },
            fingerAngle: { value: 0.0 }
          },
          vertexShader: NAIL_SHADER.vertexShader,
          fragmentShader: NAIL_SHADER.fragmentShader,
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: false,
          depthWrite: false
        });
        ['left', 'right'].forEach(handSide => {
          nails[handSide] = {};
          FINGER_KEYS.forEach(key => {
            const aspect = CONFIG.NAIL_ASPECT_RATIOS[key];
            const geometry = new THREE.PlaneGeometry(aspect, 1);
            const material = shaderMaterial.clone();
            const nail = new THREE.Mesh(geometry, material);
            nail.visible = false;
            nail.frustumCulled = false;
            nail.userData = { fingerType: key, handSide };
            nails[handSide][key] = nail;
            scene.add(nail);
          });
        });
      }
      async setupHandTracking() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 2
        });
      }
      async loadResources() {
        await this.loadDesigns();
        this.buildDesignUI();
        this.buildMaskUI();
      }
      async loadDesigns() {
        const loadImage = (name) => new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = `newyear/${name}.png`;
          img.onload = () => {
            const texture = new THREE.CanvasTexture(img);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            nailTextures[name] = texture;
            resolve();
          };
          img.onerror = () => {
            console.warn(`Failed to load design: ${name}`);
            const canvas = document.createElement('canvas');
            canvas.width = 100; canvas.height = 170;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FF6B6B'; ctx.fillRect(0, 0, 100, 170);
            ctx.fillStyle = 'white'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
            ctx.fillText(name, 50, 90);
            nailTextures[name] = new THREE.CanvasTexture(canvas);
            resolve();
          };
        });
        await Promise.all(DESIGNS.map(loadImage));
      }
      buildDesignUI() {
        elements.designPicker.innerHTML = '';
        DESIGNS.forEach(name => {
          const btn = document.createElement('img');
          btn.src = `newyear/${name}.png`;
          btn.className = `design-btn ${name === state.currentDesign ? 'selected' : ''}`;
          btn.alt = `Design ${name}`;
          btn.loading = 'lazy';
          btn.addEventListener('click', () => { this.selectDesign(name); });
          elements.designPicker.appendChild(btn);
        });
        state.customDesigns.forEach((design) => {
          const btn = document.createElement('img');
          btn.src = design.url;
          btn.className = `design-btn ${design.id === state.currentDesign ? 'selected' : ''}`;
          btn.alt = `Custom Design`;
          btn.dataset.id = design.id;
          btn.loading = 'lazy';
          btn.addEventListener('click', () => { this.selectDesign(design.id); });
          elements.designPicker.appendChild(btn);
        });
      }
      buildMaskUI() {
        elements.maskPicker.innerHTML = '';
        MASKS.forEach((mask, index) => {
          const btn = document.createElement('div');
          btn.className = `mask-btn ${mask.id === state.currentMask ? 'selected' : ''}`;
          btn.textContent = mask.name;
          btn.addEventListener('click', () => { this.selectMask(mask.id, index); });
          elements.maskPicker.appendChild(btn);
        });
      }
      startRenderLoop() {
        const render = (currentTime) => {
          if (currentTime - state.lastRenderTime >= 1000 / CONFIG.TARGET_FPS) {
            this.detectHands();
            this.renderAR();
            this.updateConfetti();
            this.updateRainbowShine();
            const time = performance.now() * 0.001;
            Object.values(nails).forEach(handNails => {
              FINGER_KEYS.forEach(key => {
                const mat = handNails[key].material;
                if (mat && mat.uniforms) {
                  mat.uniforms.time.value = time;
                  mat.uniforms.maskType.value = MASKS.findIndex(m => m.id === state.currentMask);
                }
              });
            });
            state.lastRenderTime = currentTime;
          }
          state.animationFrameId = requestAnimationFrame(render);
        };
        render(performance.now());
      }
      updateConfetti() {
        confetti = confetti.filter(p => p.life > 0);
        confetti.forEach(p => p.update());
        confettiCtx.clearRect(0, 0, elements.confettiCanvas.width, elements.confettiCanvas.height);
        confetti.forEach(p => p.draw(confettiCtx));
      }
      updateRainbowShine() {
        state.rainbowTime += 0.02;
        Object.values(nails).forEach(handNails => {
          FINGER_KEYS.forEach(key => {
            const mat = handNails[key].material;
            if (mat && mat.uniforms) {
              mat.uniforms.shineIntensity.value = 0.8 + 0.2 * Math.sin(state.rainbowTime);
            }
          });
        });
      }
      detectHands() {
        const inputSource = state.isPhotoMode ? elements.photoInput : elements.video;
        if (!handLandmarker || inputSource.readyState < 2) return;
        try {
          state.frameTimestamp = performance.now();
          const predictions = state.isPhotoMode 
            ? handLandmarker.detectForImage(elements.photoInput, state.frameTimestamp)
            : handLandmarker.detectForVideo(inputSource, state.frameTimestamp);
          state.detectedHands = [];
          if (predictions.landmarks?.length > 0) {
            state.handNotDetectedCount = 0;
            this.hideHandIndicator();
            predictions.landmarks.forEach((landmarks, handIndex) => {
              const handedness = predictions.handedness[handIndex];
              const handSide = handedness[0].categoryName.toLowerCase();
              state.detectedHands.push({ side: handSide, landmarks: this.smoothLandmarks(landmarks) });
              this.updatePalmOrientation(landmarks, handSide);
              this.calculateHandSize(landmarks);
            });
            state.lastLandmarks = state.detectedHands.map(h => h.landmarks);
          } else {
            state.handNotDetectedCount++;
            if (state.handNotDetectedCount > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
              this.showHandIndicator();
              this.hideAllNails();
            }
          }
        } catch (error) {
          console.error('Hand detection error:', error);
        }
      }
      calculateHandSize(landmarks) {
        const wristStart = landmarks[0];
        const wristEnd = landmarks[1];
        const wristDistance = Math.hypot(wristStart.x - wristEnd.x, wristStart.y - wristEnd.y);
        state.wristDistance = wristDistance;
        let scaleFactor = wristDistance / CONFIG.WRIST_DISTANCE_REF * CONFIG.SCALE_SENSITIVITY;
        scaleFactor = Math.min(scaleFactor, CONFIG.MAX_SCALE_FACTOR);
        scaleFactor = Math.max(scaleFactor, CONFIG.MIN_SCALE_FACTOR);
        state.currentHandSize = scaleFactor;
      }
      updatePalmOrientation(landmarks, handSide) {
        const wrist = landmarks[0];
        const middleMCP = landmarks[9];
        state.palmOrientation[handSide] = {
          x: (middleMCP.x - wrist.x) * window.innerWidth,
          y: (middleMCP.y - wrist.y) * window.innerHeight
        };
      }
      smoothLandmarks(newLandmarks) {
        if (!state.smoothedLandmarks) {
          state.smoothedLandmarks = newLandmarks.map(lm => ({ ...lm }));
          return state.smoothedLandmarks;
        }
        for (let i = 0; i < newLandmarks.length; i++) {
          state.smoothedLandmarks[i].x = this.lerp(state.smoothedLandmarks[i].x, newLandmarks[i].x, CONFIG.SMOOTHING_FACTOR);
          state.smoothedLandmarks[i].y = this.lerp(state.smoothedLandmarks[i].y, newLandmarks[i].y, CONFIG.SMOOTHING_FACTOR);
        }
        return state.smoothedLandmarks;
      }
      lerp(start, end, factor) { return start * (1 - factor) + end * factor; }
      renderAR() {
        if (!state.detectedHands.length) return;
        state.detectedHands.forEach(hand => {
          const handNails = nails[hand.side];
          FINGER_KEYS.forEach((key, index) => {
            const nail = handNails[key];
            if (!state.isApplyAll && index !== state.selectedFingerIndex) {
              nail.visible = false;
              return;
            }
            this.updateNailPosition(key, hand.landmarks, hand.side);
            nail.visible = true;
          });
        });
        renderer.render(scene, camera);
      }
      computeDynamicOffset(fingerKey, landmarks, handSide) {
        const { tip, pip } = FINGER_INDICES[fingerKey];
        const tipLm = landmarks[tip];
        const pipLm = landmarks[pip];
        const vec = { x: tipLm.x - pipLm.x, y: tipLm.y - pipLm.y };
        const len = Math.hypot(vec.x, vec.y);
        if (len === 0) return { x: 0, y: -0.02 };
        const normVec = { x: vec.x / len, y: vec.y / len };
        const perpVec = { x: -normVec.y, y: normVec.x };
        let offset = { x: perpVec.x * 0.01 + normVec.x * -0.005, y: perpVec.y * 0.01 + normVec.y * -0.02 };
        if (handSide === 'right') offset.x = -offset.x;
        return offset;
      }
      updateNailPosition(fingerKey, landmarks, handSide) {
        const nail = nails[handSide][fingerKey];
        if (fingerKey === 'thumb') {
          this.updateThumbNailPosition(fingerKey, landmarks, handSide);
        } else {
          this.updateFingerNailPosition(fingerKey, landmarks, handSide);
        }
        let texture = nailTextures[state.currentDesign];
        if (!texture) {
          const customDesign = state.customDesigns.find(d => d.id === state.currentDesign);
          if (customDesign) texture = customDesign.texture;
        }
        if (texture) {
          nail.material.uniforms.map.value = texture;
          nail.material.needsUpdate = true;
        }
        const { tip, pip } = FINGER_INDICES[fingerKey];
        const tipLm = landmarks[tip];
        const pipLm = landmarks[pip];
        const angle = Math.atan2(tipLm.y - pipLm.y, tipLm.x - pipLm.x);
        nail.material.uniforms.fingerAngle.value = angle;
      }
      updateThumbNailPosition(fingerKey, landmarks, handSide) {
        const nail = nails[handSide][fingerKey];
        const { tip, mcp, ip } = FINGER_INDICES[fingerKey];
        const tipLandmark = landmarks[tip];
        const mcpLandmark = landmarks[mcp];
        const ipLandmark = landmarks[ip];
        const dynamicOffset = this.computeDynamicOffset(fingerKey, landmarks, handSide);
        const screenX = (tipLandmark.x + dynamicOffset.x) * window.innerWidth;
        const screenY = (1 - (tipLandmark.y + dynamicOffset.y)) * window.innerHeight;
        const thumbLength = Math.hypot(
          (tipLandmark.x - mcpLandmark.x) * window.innerWidth,
          (tipLandmark.y - mcpLandmark.y) * window.innerHeight
        );
        let nailHeight = thumbLength * CONFIG.NAIL_SCALE_FACTORS.thumb * state.currentHandSize;
        nailHeight = Math.max(CONFIG.MIN_SIZE, Math.min(CONFIG.MAX_SIZE, nailHeight));
        const angle = Math.atan2(tipLandmark.y - ipLandmark.y, tipLandmark.x - ipLandmark.x);
        nail.position.set(screenX - window.innerWidth / 2, screenY - window.innerHeight / 2, 0);
        const aspect = CONFIG.NAIL_ASPECT_RATIOS[fingerKey];
        nail.scale.set(nailHeight * aspect, nailHeight, 1);
        nail.rotation.z = angle;
      }
      updateFingerNailPosition(fingerKey, landmarks, handSide) {
        const nail = nails[handSide][fingerKey];
        const { tip, pip } = FINGER_INDICES[fingerKey];
        const tipLandmark = landmarks[tip];
        const pipLandmark = landmarks[pip];
        const dynamicOffset = this.computeDynamicOffset(fingerKey, landmarks, handSide);
        const screenX = (tipLandmark.x + dynamicOffset.x) * window.innerWidth;
        const screenY = (1 - (tipLandmark.y + dynamicOffset.y)) * window.innerHeight;
        const fingerLength = Math.hypot(
          (tipLandmark.x - pipLandmark.x) * window.innerWidth,
          (tipLandmark.y - pipLandmark.y) * window.innerHeight
        );
        let nailHeight = fingerLength * CONFIG.NAIL_SCALE_FACTORS[fingerKey] * state.currentHandSize;
        nailHeight = Math.max(CONFIG.MIN_SIZE, Math.min(CONFIG.MAX_SIZE, nailHeight));
        const angle = Math.atan2(tipLandmark.y - pipLandmark.y, tipLandmark.x - pipLandmark.x);
        nail.position.set(screenX - window.innerWidth / 2, screenY - window.innerHeight / 2, 0);
        const aspect = CONFIG.NAIL_ASPECT_RATIOS[fingerKey];
        nail.scale.set(nailHeight * aspect, nailHeight, 1);
        nail.rotation.z = angle;
      }
      hideAllNails() {
        Object.values(nails).forEach(handNails => {
          FINGER_KEYS.forEach(key => handNails[key].visible = false);
        });
        renderer.render(scene, camera);
      }
      handleCanvasClick(event) {
        if (state.isApplyAll || !state.detectedHands.length) return;
        event.preventDefault();
        const rect = elements.canvas.getBoundingClientRect();
        const x = (event.clientX || event.touches[0].clientX) - rect.left;
        const y = (event.clientY || event.touches[0].clientY) - rect.top;
        state.selectedFingerIndex = this.getClosestFinger(x, y);
      }
      getClosestFinger(touchX, touchY) {
        let minDist = Infinity, closestIndex = -1;
        state.detectedHands.forEach((hand, handIdx) => {
          FINGER_KEYS.forEach((key, index) => {
            const tipIndex = FINGER_INDICES[key].tip;
            const landmark = hand.landmarks[tipIndex];
            const x = landmark.x * window.innerWidth;
            const y = (1 - landmark.y) * window.innerHeight;
            const dist = Math.hypot(touchX - x, touchY - y);
            if (dist < minDist && dist < window.innerWidth * 0.1) {
              minDist = dist;
              closestIndex = index;
            }
          });
        });
        return closestIndex;
      }
      toggleLanguage() {
        state.currentLang = state.currentLang === 'en' ? 'uk' : 'en';
        this.updateUI();
        elements.langBtn.textContent = state.currentLang === 'en' ? 'UK' : 'EN';
      }
      setApplyAllMode() {
        state.isApplyAll = true;
        state.selectedFingerIndex = -1;
        elements.applyAllBtn.classList.add('active');
        elements.selectFingerBtn.classList.remove('active');
      }
      setSelectFingerMode() {
        state.isApplyAll = false;
        elements.applyAllBtn.classList.remove('active');
        elements.selectFingerBtn.classList.add('active');
      }
      selectDesign(name) {
        state.currentDesign = name;
        document.querySelectorAll('.design-btn').forEach(btn => {
          btn.classList.toggle('selected', btn.src.includes(`${name}.png`) || btn.dataset.id === name);
        });
        this.triggerConfetti();
      }
      selectMask(maskId, index) {
        state.currentMask = maskId;
        document.querySelectorAll('.mask-btn').forEach((btn, i) => {
          btn.classList.toggle('selected', i === index);
        });
      }
      uploadDesigns() {
        elements.designUpload.click();
      }
      handleDesignUpload(event) {
        // ‚Äî‚Äî‚Äî –ó–∞–ª–∏—à–∏–≤ —Ç–≤—ñ–π –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω–∏–π –∫–æ–¥ –±–µ–∑ –∑–º—ñ–Ω ‚Äî‚Äî‚Äî
        Array.from(event.target.files).forEach(file => {
          if (!file.type.startsWith('image/')) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            const img = new Image();
            img.onload = () => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const maxDim = 512;
              const { width, height } = img;
              if (width > maxDim || height > maxDim) {
                const scale = Math.min(maxDim / width, maxDim / height);
                canvas.width = width * scale;
                canvas.height = height * scale;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              } else {
                canvas.width = width;
                canvas.height = height;
                ctx.drawImage(img, 0, 0);
              }
              const texture = new THREE.CanvasTexture(canvas);
              texture.wrapS = THREE.ClampToEdgeWrapping;
              texture.wrapT = THREE.ClampToEdgeWrapping;
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.format = THREE.RGBAFormat;
              texture.generateMipmaps = false;
              const designId = `custom_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
              state.customDesigns.push({
                id: designId,
                url: e.target.result,
                texture: texture
              });
              this.buildDesignUI();
              this.selectDesign(designId);
            };
            img.src = e.target.result;
          };
          reader.readAsDataURL(file);
        });
        event.target.value = '';
      }
      uploadHandPhoto() {
        elements.photoUpload.click();
      }
      handleHandPhotoUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          elements.photoInput.src = e.target.result;
          elements.photoInput.onload = () => {
            // ‚úÖ –ó–£–ü–ò–ù–ö–ê –í–Ü–î–ï–û –°–¢–†–Ü–ú–£ –¥–ª—è —Å–ª–∞–±–∫–∏—Ö –ø—Ä–∏—Å—Ç—Ä–æ—ó–≤
            if (elements.video.srcObject) {
              elements.video.srcObject.getTracks().forEach(track => track.stop());
              elements.video.srcObject = null;
            }
            state.isPhotoMode = true;
            elements.video.style.display = 'none';
            elements.photoInput.style.display = 'block';
            handLandmarker.setOptions({ runningMode: 'IMAGE' });
            this.updateUI();
            document.querySelector('#loading p').textContent = translations[state.currentLang].photoCalib;
          };
        };
        reader.readAsDataURL(file);
        event.target.value = '';
      }
      triggerConfetti() {
        const rect = elements.designPicker.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        for (let i = 0; i < 30; i++) {
          confetti.push(new ConfettiParticle(x + (Math.random() - 0.5) * 100, y));
        }
      }
      updateUI() {
        const t = translations[state.currentLang];
        document.title = t.title;
        elements.loadingText.textContent = t.loading;
        document.querySelector('#loading p').textContent = state.isPhotoMode ? t.photoCalib : t.cameraPrompt;
        elements.applyAllBtn.textContent = t.allFingers;
        elements.selectFingerBtn.textContent = t.pickFinger;
        elements.handIndicator.innerHTML = `<span>Hand</span><span>${t.handNotDetected}</span>`;
        elements.cameraIndicator.innerHTML = `<span>Camera</span><span>${t.cameraActive}</span>`;
        elements.langBtn.textContent = state.currentLang === 'en' ? 'UK' : 'EN';
        this.updateSoundButton();
        elements.photoUploadBtn.textContent = state.isPhotoMode ? 'üîÑ Live' : 'üì∏ Photo';
      }
      updateSoundButton() {
        elements.soundBtn.textContent = state.isMuted ? 'Muted' : 'Sound';
      }
      showCameraIndicator() {
        elements.cameraIndicator.classList.add('show');
        setTimeout(() => elements.cameraIndicator.classList.remove('show'), 3000);
      }
      showHandIndicator() { elements.handIndicator.classList.add('show'); }
      hideHandIndicator() { elements.handIndicator.classList.remove('show'); }
      hideLoading() {
        elements.loading.style.display = 'none';
        if (state.isPhotoMode) {
          elements.photoInput.style.display = 'block';
        } else {
          elements.video.style.display = 'block';
        }
        elements.canvas.style.display = 'block';
      }
      handleResize() {
        if (!camera || !renderer) return;
        const aspect = window.innerWidth / window.innerHeight;
        camera.left = -window.innerWidth / 2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = -window.innerHeight / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if (state.isPhotoMode) {
          setTimeout(() => this.detectHands(), 100);
        }
      }
      handleError(error) {
        console.error('App error:', error);
        const t = translations[state.currentLang];
        let message = error.message === 'CAMERA_ERROR' ? t.cameraError : t.arError;
        elements.loading.innerHTML = `
          <div style="color: #ff4757; font-size: 24px; margin-bottom: 20px;">Error</div>
          <div style="color: white; font-size: 18px; margin-bottom: 20px; line-height: 1.4;">${message}</div>
          <button id="errorRetry">${t.retry}</button>
        `;
        elements.loading.style.display = 'flex';
        document.getElementById('errorRetry').addEventListener('click', () => location.reload());
      }
      cleanup() {
        if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
        if (elements.video.srcObject) elements.video.srcObject.getTracks().forEach(track => track.stop());
        if (handLandmarker) handLandmarker.close();
      }
    }
    window.addEventListener('DOMContentLoaded', () => {
      if (!navigator.onLine) {
        document.getElementById('loading').innerHTML = `
          <div style="color: #ff4757; font-size: 24px;">Offline</div>
          <p style="color: white; max-width: 300px; line-height: 1.4;">This app requires internet to load AR models and designs.</p>
        `;
      } else {
        new NailARApplication();
      }
    });
  </script>
</body>
</html>
