<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Christmas Nail AR Try-On</title>
  <link rel="icon" type="image/png" href="data:image/png;base64,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">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: manipulation;
    }
    body {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4, #fad0c4);
      overflow: hidden;
      font-family: 'Arial', 'Segoe UI', system-ui, sans-serif;
      color: white;
    }
    #video, #canvas, #confettiCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #video { z-index: 1; display: none; }
    #canvas { z-index: 2; display: none; }
    #confettiCanvas { z-index: 60; pointer-events: none; }
    .control-btn {
      position: fixed;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 255, 255, 0.4);
      color: white;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    }
    .control-btn:hover { transform: scale(1.15); background: rgba(255, 255, 255, 0.3); }
    #langBtn { top: 20px; right: 20px; font-weight: bold; font-size: 16px; }
    #soundBtn { top: 20px; left: 20px; }
    #uploadBtn { top: 80px; left: 20px; }
    #authorBtn {
      position: fixed;
      top: 78px;
      right: 20px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      border: 3px solid #ffd700;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      z-index: 100;
      transition: all 0.3s ease;
      box-shadow: 0 6px 20px rgba(255, 71, 87, 0.5), 0 0 0 4px #ffd700;
      animation: pulse-glow 2s infinite;
    }
    #authorBtn:hover {
      transform: scale(1.2) rotate(10deg);
      background: linear-gradient(135deg, #ff4757, #ff6b6b);
      box-shadow: 0 8px 25px rgba(255, 71, 87, 0.7), 0 0 0 6px #ffd700;
    }
    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 6px 20px rgba(255, 71, 87, 0.5), 0 0 0 4px #ffd700; }
      50% { box-shadow: 0 8px 30px rgba(255, 71, 87, 0.7), 0 0 0 6px #ffd700; }
    }
    #modeControls {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.4);
      backdrop-filter: blur(20px);
      padding: 6px 12px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      max-width: calc(100% - 120px);
    }
    .mode-btn {
      padding: 8px 16px;
      border-radius: 20px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      border: none;
      font-weight: 600;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      white-space: nowrap;
    }
    .mode-btn:hover { transform: translateY(-2px); }
    .mode-btn.active { background: linear-gradient(135deg, #ff6b6b, #ff4757); animation: pulse 2s infinite; }
    #designPicker {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(20px);
      padding: 15px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      max-width: 90vw;
      overflow-x: auto;
      scrollbar-width: none;
    }
    #designPicker::-webkit-scrollbar { display: none; }
    .design-btn {
      width: 60px;
      height: 90px;
      border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      object-fit: contain;
      background: transparent;
      cursor: pointer;
      transition: all 0.3s ease;
      flex-shrink: 0;
    }
    .design-btn:hover { transform: scale(1.1); border-color: rgba(255, 255, 255, 0.6); }
    .design-btn.selected { transform: scale(1.15); border-color: #ffd700; box-shadow: 0 0 0 3px #ffd700; }
    #maskPicker {
      position: fixed;
      bottom: 150px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 12px;
      z-index: 100;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(20px);
      padding: 15px;
      border-radius: 25px;
      border: 1px solid rgba(255, 255, 255, 0.3);
      max-width: 90vw;
      overflow-x: auto;
      scrollbar-width: none;
    }
    #maskPicker::-webkit-scrollbar { display: none; }
    .mask-btn {
      width: 60px;
      height: 60px;
      border-radius: 16px;
      border: 3px solid rgba(255, 255, 255, 0.3);
      background: transparent;
      cursor: pointer;
      transition: all 0.3s ease;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 12px;
      text-align: center;
    }
    .mask-btn:hover { transform: scale(1.1); border-color: rgba(255, 255, 255, 0.6); }
    .mask-btn.selected { transform: scale(1.15); border-color: #ffd700; box-shadow: 0 0 0 3px #ffd700; }
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      color: #ff6b6b;
      font-size: clamp(18px, 4vw, 24px);
      text-align: center;
      padding: 20px;
      gap: 20px;
    }
    .loader {
      width: 60px;
      height: 60px;
      border: 4px solid rgba(255, 107, 107, 0.3);
      border-top: 4px solid #ff6b6b;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    #loading p {
      color: #fff;
      font-size: clamp(14px, 3vw, 18px);
      max-width: 300px;
      line-height: 1.4;
    }
    .indicator {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      backdrop-filter: blur(10px);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: none;
      align-items: center;
      gap: 8px;
      z-index: 99;
      font-size: 14px;
    }
    #cameraIndicator { top: 20px; }
    #handIndicator { top: 160px; }
    .indicator.show { display: flex; animation: slideDown 0.3s ease; }
    #errorRetry {
      margin-top: 20px;
      padding: 12px 24px;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      border: none;
      color: white;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 25px;
      transition: all 0.3s ease;
    }
    #errorRetry:hover { transform: translateY(-2px); }
    @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    @keyframes slideDown {
      from { opacity: 0; transform: translateX(-50%) translateY(-10px); }
      to { opacity: 1; transform: translateX(-50%) translateY(0); }
    }
    @media (max-width: 768px) {
      .control-btn { width: 44px; height: 44px; font-size: 17px; }
      #authorBtn { width: 50px; height: 50px; top: 74px; font-size: 22px; }
      #modeControls { top: 18px; gap: 8px; padding: 5px 10px; }
      .mode-btn { padding: 7px 14px; font-size: 12px; }
      .design-btn { width: 50px; height: 75px; }
      .mask-btn { width: 50px; height: 50px; font-size: 10px; }
      #maskPicker { bottom: 140px; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <div class="loader"></div>
    <div id="loadingText">Loading Christmas Nail Magic...</div>
    <p>Please allow camera access</p>
  </div>
  <video id="video" playsinline muted></video>
  <canvas id="canvas"></canvas>
  <canvas id="confettiCanvas"></canvas>
  <input type="file" id="designUpload" accept="image/*" style="display: none;">
  <button id="langBtn" class="control-btn" aria-label="Switch language">UK</button>
  <button id="soundBtn" class="control-btn" aria-label="Toggle sound">Sound</button>
  <button id="uploadBtn" class="control-btn" aria-label="Upload custom design">üìÅ</button>
  <a href="https://smartlessa.etsy.com" target="_blank" rel="noopener" id="authorBtn" aria-label="Author: smartlessa.etsy.com">
    Author
  </a>
  <div id="modeControls">
    <button class="mode-btn active" id="applyAllBtn" aria-label="Apply to all fingers">All Fingers</button>
    <button class="mode-btn" id="selectFingerBtn" aria-label="Select finger">Select Finger</button>
  </div>
  <div id="maskPicker"></div>
  <div id="designPicker"></div>
  <div id="cameraIndicator" class="indicator">
    <span>Camera</span>
    <span>Camera Active</span>
  </div>
  <div id="handIndicator" class="indicator">
    <span>Hand</span>
    <span>Show your hand</span>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { FilesetResolver, HandLandmarker } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    const CONFIG = {
      SMOOTHING_FACTOR: 0.7,
      HAND_NOT_DETECTED_THRESHOLD: 10,
      NAIL_SCALE_FACTORS: {
        thumb: 0.35,
        index: 0.45,
        middle: 0.47,
        ring: 0.45,
        pinky: 0.35
      },
      NAIL_ASPECT_RATIOS: {
        thumb: 0.75,
        index: 0.80,
        middle: 0.82,
        ring: 0.80,
        pinky: 0.85
      },
      NAIL_OFFSETS: {
        thumb: { x: -0.01, y: -0.02 },
        index: { x: 0, y: -0.02 },
        middle: { x: 0, y: -0.025 },
        ring: { x: 0, y: -0.02 },
        pinky: { x: 0.005, y: -0.015 }
      },
      MIN_SIZE: 25,
      MAX_SIZE: 85,
      WRIST_DISTANCE_REF: 0.1,
      SCALE_SENSITIVITY: 1.8,
      MAX_SCALE_FACTOR: 2.0,
      MIN_SCALE_FACTOR: 0.6
    };

    const FINGER_INDICES = {
      thumb: { tip: 4, mcp: 2, pip: 3, ip: 3 },
      index: { tip: 8, mcp: 5, pip: 6, dip: 7 },
      middle: { tip: 12, mcp: 9, pip: 10, dip: 11 },
      ring: { tip: 16, mcp: 13, pip: 14, dip: 15 },
      pinky: { tip: 20, mcp: 17, pip: 18, dip: 19 }
    };

    const FINGER_KEYS = Object.keys(FINGER_INDICES);

    const translations = {
      en: {
        title: "Christmas Nail AR Try-On",
        loading: "Loading Christmas Nail Magic...",
        cameraPrompt: "Please allow camera access",
        allFingers: "All Fingers",
        pickFinger: "Select Finger",
        cameraError: "Camera access denied.<br>Try Chrome or Safari.",
        arError: "AR failed to load.<br>Refresh page.",
        retry: "Retry",
        cameraActive: "Camera Active",
        handNotDetected: "Show your hand"
      },
      uk: {
        title: "–†—ñ–∑–¥–≤—è–Ω–∏–π –º–∞–Ω—ñ–∫—é—Ä!",
        loading: "–ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –†—ñ–∑–¥–≤—è–Ω–æ–≥–æ –º–∞–Ω—ñ–∫—é—Ä—É...",
        cameraPrompt: "–î–æ–∑–≤–æ–ª—å—Ç–µ –¥–æ—Å—Ç—É–ø –¥–æ –∫–∞–º–µ—Ä–∏",
        allFingers: "–£—Å—ñ –ø–∞–ª—å—Ü—ñ",
        pickFinger: "–û–±—Ä–∞—Ç–∏ –ø–∞–ª–µ—Ü—å",
        cameraError: "–ù–µ–º–∞—î –¥–æ—Å—Ç—É–ø—É –¥–æ –∫–∞–º–µ—Ä–∏.<br>–°–ø—Ä–æ–±—É–π—Ç–µ Chrome –∞–±–æ Safari.",
        arError: "–ü–æ–º–∏–ª–∫–∞ AR.<br>–û–Ω–æ–≤—ñ—Ç—å —Å—Ç–æ—Ä—ñ–Ω–∫—É.",
        retry: "–ü–æ–≤—Ç–æ—Ä–∏—Ç–∏",
        cameraActive: "–ö–∞–º–µ—Ä–∞ –∞–∫—Ç–∏–≤–Ω–∞",
        handNotDetected: "–ü–æ–∫–∞–∂–∏ —Ä—É–∫—É"
      }
    };

    const state = {
      currentLang: 'en',
      currentDesign: "1",
      currentMask: "none",
      isApplyAll: true,
      selectedFingerIndex: -1,
      isMuted: false,
      lastLandmarks: null,
      smoothedLandmarks: null,
      handNotDetectedCount: 0,
      animationFrameId: null,
      palmOrientation: { x: 0, y: 0 },
      currentHandSize: 1.0,
      wristDistance: 0,
      rainbowTime: 0,
      isAudioUnlocked: false,
      customDesigns: [],
      frameTimestamp: 0
    };

    const elements = {
      video: document.getElementById("video"),
      canvas: document.getElementById("canvas"),
      confettiCanvas: document.getElementById("confettiCanvas"),
      designUpload: document.getElementById("designUpload"),
      loading: document.getElementById("loading"),
      loadingText: document.getElementById("loadingText"),
      langBtn: document.getElementById("langBtn"),
      soundBtn: document.getElementById("soundBtn"),
      uploadBtn: document.getElementById("uploadBtn"),
      authorBtn: document.getElementById("authorBtn"),
      applyAllBtn: document.getElementById("applyAllBtn"),
      selectFingerBtn: document.getElementById("selectFingerBtn"),
      designPicker: document.getElementById("designPicker"),
      maskPicker: document.getElementById("maskPicker"),
      cameraIndicator: document.getElementById("cameraIndicator"),
      handIndicator: document.getElementById("handIndicator")
    };

    const confettiCtx = elements.confettiCanvas.getContext("2d");
    let confetti = [];

    function resizeCanvases() {
      elements.confettiCanvas.width = window.innerWidth;
      elements.confettiCanvas.height = window.innerHeight;
    }
    resizeCanvases();
    window.addEventListener('resize', resizeCanvases);

    const audio = {
      bgMusic: new Audio('audio/bg-music.mp3')
    };
    audio.bgMusic.loop = true;
    audio.bgMusic.volume = 0.4;

    const DESIGNS = ["1", "2", "3"];

    const MASKS = [
      { id: "none", name: "None" },
      { id: "square", name: "Square" },
      { id: "squared_oval", name: "Squared Oval" },
      { id: "oval", name: "Oval" },
      { id: "rounded", name: "Rounded" },
      { id: "almond", name: "Almond" },
      { id: "mountain_peak", name: "Mountain Peak" },
      { id: "stiletto", name: "Stiletto" },
      { id: "ballerina", name: "Ballerina" },
      { id: "edge", name: "Edge" },
      { id: "lipstick", name: "Lipstick" },
      { id: "flare", name: "Flare" },
      { id: "arrow_head", name: "Arrow Head" }
    ];

    const nailTextures = {};
    let scene, camera, renderer;
    const nails = {};
    let handLandmarker;

    const NAIL_SHADER = {
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        void main() {
          vUv = uv;
          vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
          vViewPosition = -mvPosition.xyz;
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      fragmentShader: `
        uniform sampler2D map;
        uniform float time;
        uniform float shineIntensity;
        uniform int maskType;
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vViewPosition;
        vec3 rainbow(float t) {
          return vec3(
            0.5 + 0.5 * sin(t),
            0.5 + 0.5 * sin(t + 2.0),
            0.5 + 0.5 * sin(t + 4.0)
          );
        }
        float ovalMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float r = 0.5;
          float ellipse = (d.x * d.x) / (r * r) + (d.y * d.y) / (r * r * 0.7);
          return 1.0 - smoothstep(0.99, 1.0, ellipse);
        }
        float roundedSquareMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = abs(uv - center);
          float radius = 0.1;
          vec2 q = d - vec2(0.5 - radius);
          float dist = length(max(q, 0.0)) + min(max(q.x, q.y), 0.0) - radius;
          return 1.0 - smoothstep(0.0, 0.01, dist);
        }
        float fleurMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float angle = atan(d.y, d.x);
          float r = length(d) * 2.0;
          float flower = 0.5 + 0.3 * cos(6.0 * angle);
          return 1.0 - smoothstep(flower - 0.05, flower, r);
        }
        float gelEffect(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          float dist = distance(uv, center);
          float shine = 0.8 + 0.2 * sin(time * 3.0 + dist * 10.0);
          return shine;
        }
        float squareMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = abs(uv - center);
          float size = 0.45;
          float edge = 0.05;
          if (d.x > size || d.y > size) return 0.0;
          if (d.x < size - edge && d.y < size - edge) return 1.0;
          return 1.0 - smoothstep(size - edge, size, max(d.x, d.y));
        }
        float squovalMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.2;
          float dy = d.y * 0.8;
          float r = sqrt(dx*dx + dy*dy);
          return 1.0 - smoothstep(0.45, 0.5, r);
        }
        float roundedMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float r = length(d);
          return 1.0 - smoothstep(0.45, 0.5, r);
        }
        float almondMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.5;
          float dy = d.y * 1.2;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.3 * cos(4.0 * angle);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float mountainPeakMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.5;
          float dy = d.y * 1.2;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.3 * cos(5.0 * angle + 3.14159);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float stilettoMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.5;
          float dy = d.y * 1.2;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.3 * cos(5.0 * angle);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float ballerinaMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.3;
          float dy = d.y * 1.0;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.2 * cos(4.0 * angle + 3.14159);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float edgeMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.5;
          float dy = d.y * 1.0;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.3 * cos(6.0 * angle);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float lipstickMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.2;
          float dy = d.y * 1.0;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.2 * cos(4.0 * angle);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float flareMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.4;
          float dy = d.y * 1.0;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.3 * cos(5.0 * angle);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        float arrowHeadMask(vec2 uv) {
          vec2 center = vec2(0.5, 0.5);
          vec2 d = uv - center;
          float dx = d.x * 1.5;
          float dy = d.y * 1.2;
          float r = sqrt(dx*dx + dy*dy);
          float angle = atan(dy, dx);
          float shape = 0.5 + 0.3 * cos(6.0 * angle + 3.14159);
          return 1.0 - smoothstep(shape - 0.05, shape, r);
        }
        void main() {
          vec4 texColor = texture2D(map, vUv);
          if (texColor.a < 0.1) discard;
          vec3 color = texColor.rgb;
          float mask = 1.0;
          if (maskType == 1) {
            mask = squareMask(vUv);
          } else if (maskType == 2) {
            mask = squovalMask(vUv);
          } else if (maskType == 3) {
            mask = ovalMask(vUv);
          } else if (maskType == 4) {
            mask = roundedMask(vUv);
          } else if (maskType == 5) {
            mask = almondMask(vUv);
          } else if (maskType == 6) {
            mask = mountainPeakMask(vUv);
          } else if (maskType == 7) {
            mask = stilettoMask(vUv);
          } else if (maskType == 8) {
            mask = ballerinaMask(vUv);
          } else if (maskType == 9) {
            mask = edgeMask(vUv);
          } else if (maskType == 10) {
            mask = lipstickMask(vUv);
          } else if (maskType == 11) {
            mask = flareMask(vUv);
          } else if (maskType == 12) {
            mask = arrowHeadMask(vUv);
          } else if (maskType == 13) {
            float gel = gelEffect(vUv);
            color *= gel;
          }
          float shine = smoothstep(0.3, 0.7, vUv.y + sin(vUv.y * 8.0 - time * 1.5) * 0.1);
          shine = pow(shine, 2.0) * 0.5;
          vec3 highlight = rainbow(time * 3.0) * shine * shineIntensity;
          float fresnel = pow(1.0 - dot(normalize(vViewPosition), vNormal), 3.0);
          vec3 rim = vec3(1.0, 0.9, 0.8) * fresnel * 0.3;
          float shadow = smoothstep(0.0, 0.25, vUv.y);
          color *= (1.0 - shadow * 0.25);
          color = color + highlight + rim;
          gl_FragColor = vec4(color, texColor.a * mask);
        }
      `
    };

    class ConfettiParticle {
      constructor(x, y) {
        this.x = x; this.y = y;
        this.vx = (Math.random() - 0.5) * 8;
        this.vy = Math.random() * -15 - 5;
        this.size = Math.random() * 6 + 4;
        this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
        this.life = 1.0;
        this.gravity = 0.4;
        this.rotation = Math.random() * Math.PI * 2;
        this.spin = (Math.random() - 0.5) * 0.3;
      }
      update() {
        this.vy += this.gravity;
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.015;
        this.rotation += this.spin;
      }
      draw(ctx) {
        if (this.life <= 0) return;
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.fillStyle = this.color;
        ctx.fillRect(-this.size / 2, -this.size / 2, this.size, this.size);
        ctx.restore();
      }
    }

    class NailARApplication {
      constructor() { this.init(); }
      async init() {
        try {
          this.setupEventListeners();
          await this.setupCamera();
          await this.initWebGL();
          await this.setupHandTracking();
          await this.loadResources();
          this.setupAudio();
          this.updateUI();
          this.hideLoading();
          this.startRenderLoop();
          this.unlockAudio();
        } catch (error) {
          this.handleError(error);
        }
      }

      unlockAudio() {
        const unlock = () => {
          if (state.isAudioUnlocked) return;
          state.isAudioUnlocked = true;
          if (!state.isMuted) {
            audio.bgMusic.play().catch(() => {});
          }
          document.removeEventListener('click', unlock);
          document.removeEventListener('touchstart', unlock);
        };
        document.addEventListener('click', unlock, { once: true });
        document.addEventListener('touchstart', unlock, { once: true });
      }

      setupAudio() {}
      toggleSound() {
        state.isMuted = !state.isMuted;
        if (state.isMuted) {
          audio.bgMusic.pause();
        } else if (state.isAudioUnlocked) {
          audio.bgMusic.play().catch(() => {});
        }
        this.updateSoundButton();
      }

      setupEventListeners() {
        elements.langBtn.addEventListener('click', () => this.toggleLanguage());
        elements.soundBtn.addEventListener('click', () => this.toggleSound());
        elements.uploadBtn.addEventListener('click', () => this.uploadDesign());
        elements.designUpload.addEventListener('change', (e) => this.handleDesignUpload(e));
        elements.applyAllBtn.addEventListener('click', () => this.setApplyAllMode());
        elements.selectFingerBtn.addEventListener('click', () => this.setSelectFingerMode());
        elements.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        elements.canvas.addEventListener('touchstart', (e) => {
          e.preventDefault();
          this.handleCanvasClick(e);
        });
        window.addEventListener('resize', () => {
          this.handleResize();
          resizeCanvases();
        });
        window.addEventListener('beforeunload', () => this.cleanup());
      }

      async setupCamera() {
        try {
          const constraints = { video: { facingMode: "environment", width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 30 } } };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          elements.video.srcObject = stream;
          await new Promise(r => { elements.video.onloadedmetadata = () => { elements.video.play(); r(); }; });
          this.showCameraIndicator();
        } catch (error) {
          console.error('Camera setup failed:', error);
          throw new Error('CAMERA_ERROR');
        }
      }

      async initWebGL() {
        scene = new THREE.Scene();
        camera = new THREE.OrthographicCamera(
          -window.innerWidth / 2,
          window.innerWidth / 2,
          window.innerHeight / 2,
          -window.innerHeight / 2,
          0.1,
          1000
        );
        camera.position.z = 10;
        renderer = new THREE.WebGLRenderer({
          canvas: elements.canvas,
          alpha: true,
          antialias: true,
          powerPreference: "high-performance"
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.createNails();
      }

      createNails() {
        const shaderMaterial = new THREE.ShaderMaterial({
          uniforms: {
            map: { value: null },
            time: { value: 0 },
            shineIntensity: { value: 1.0 },
            maskType: { value: 0 }
          },
          vertexShader: NAIL_SHADER.vertexShader,
          fragmentShader: NAIL_SHADER.fragmentShader,
          transparent: true,
          side: THREE.DoubleSide,
          depthTest: false,
          depthWrite: false
        });
        FINGER_KEYS.forEach(key => {
          const aspect = CONFIG.NAIL_ASPECT_RATIOS[key];
          const geometry = new THREE.PlaneGeometry(aspect, 1);
          const material = shaderMaterial.clone();
          const nail = new THREE.Mesh(geometry, material);
          nail.visible = false;
          nail.frustumCulled = false;
          nail.userData.fingerType = key;
          nails[key] = nail;
          scene.add(nail);
        });
      }

      async setupHandTracking() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
            delegate: "GPU"
          },
          runningMode: "VIDEO",
          numHands: 1
        });
      }

      async loadResources() {
        await this.loadDesigns();
        this.buildDesignUI();
        this.buildMaskUI();
      }

      async loadDesigns() {
        const loadImage = (name) => new Promise((resolve) => {
          const img = new Image();
          img.crossOrigin = "anonymous";
          img.src = `newyear/${name}.png`;
          img.onload = () => {
            const texture = new THREE.CanvasTexture(img);
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            nailTextures[name] = texture;
            resolve();
          };
          img.onerror = () => {
            console.warn(`Failed to load design: ${name}`);
            const canvas = document.createElement('canvas');
            canvas.width = 100; canvas.height = 170;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FF6B6B'; ctx.fillRect(0, 0, 100, 170);
            ctx.fillStyle = 'white'; ctx.font = '16px Arial'; ctx.textAlign = 'center';
            ctx.fillText(name, 50, 90);
            nailTextures[name] = new THREE.CanvasTexture(canvas);
            resolve();
          };
        });
        await Promise.all(DESIGNS.map(loadImage));
      }

      buildDesignUI() {
        elements.designPicker.innerHTML = '';
        DESIGNS.forEach(name => {
          const btn = document.createElement('img');
          btn.src = `newyear/${name}.png`;
          btn.className = `design-btn ${name === state.currentDesign ? 'selected' : ''}`;
          btn.alt = `Design ${name}`;
          btn.loading = 'lazy';
          btn.addEventListener('click', () => { this.selectDesign(name); });
          elements.designPicker.appendChild(btn);
        });
        state.customDesigns.forEach((design) => {
          const btn = document.createElement('img');
          btn.src = design.url;
          btn.className = `design-btn ${design.id === state.currentDesign ? 'selected' : ''}`;
          btn.alt = `Custom Design`;
          btn.dataset.id = design.id;
          btn.loading = 'lazy';
          btn.addEventListener('click', () => { this.selectDesign(design.id); });
          elements.designPicker.appendChild(btn);
        });
      }

      buildMaskUI() {
        elements.maskPicker.innerHTML = '';
        MASKS.forEach((mask, index) => {
          const btn = document.createElement('div');
          btn.className = `mask-btn ${mask.id === state.currentMask ? 'selected' : ''}`;
          btn.textContent = mask.name;
          btn.addEventListener('click', () => { this.selectMask(mask.id, index); });
          elements.maskPicker.appendChild(btn);
        });
      }

      startRenderLoop() {
        const render = () => {
          this.detectHands();
          this.renderAR();
          this.updateConfetti();
          this.updateRainbowShine();
          const time = performance.now() * 0.001;
          FINGER_KEYS.forEach(key => {
            const mat = nails[key].material;
            if (mat && mat.uniforms) {
              mat.uniforms.time.value = time;
              mat.uniforms.maskType.value = MASKS.findIndex(m => m.id === state.currentMask);
            }
          });
          state.animationFrameId = requestAnimationFrame(render);
        };
        render();
      }

      updateConfetti() {
        confetti = confetti.filter(p => p.life > 0);
        confetti.forEach(p => p.update());
        confettiCtx.clearRect(0, 0, elements.confettiCanvas.width, elements.confettiCanvas.height);
        confetti.forEach(p => p.draw(confettiCtx));
      }

      updateRainbowShine() {
        state.rainbowTime += 0.02;
        FINGER_KEYS.forEach(key => {
          const mat = nails[key].material;
          if (mat && mat.uniforms) {
            mat.uniforms.shineIntensity.value = 0.8 + 0.2 * Math.sin(state.rainbowTime);
          }
        });
      }

      detectHands() {
        if (!handLandmarker || elements.video.readyState < 2) return;
        try {
          state.frameTimestamp += 33;
          const predictions = handLandmarker.detectForVideo(elements.video, state.frameTimestamp);
          if (predictions.landmarks?.length > 0) {
            state.handNotDetectedCount = 0;
            this.hideHandIndicator();
            const landmarks = predictions.landmarks[0];
            state.lastLandmarks = this.smoothLandmarks(landmarks);
            this.updatePalmOrientation(landmarks);
            this.calculateHandSize(landmarks);
          } else {
            state.handNotDetectedCount++;
            if (state.handNotDetectedCount > CONFIG.HAND_NOT_DETECTED_THRESHOLD) {
              this.showHandIndicator();
              this.hideAllNails();
            }
          }
        } catch (error) {
          console.error('Hand detection error:', error);
        }
      }

      // ‚Äî‚Äî‚Äî —Ä–µ—à—Ç–∞ –º–µ—Ç–æ–¥—ñ–≤ (–±–µ–∑ –∑–º—ñ–Ω) ‚Äî‚Äî‚Äî
      calculateHandSize(landmarks) {
        const wristStart = landmarks[0];
        const wristEnd = landmarks[1];
        const wristDistance = Math.hypot(wristStart.x - wristEnd.x, wristStart.y - wristEnd.y);
        state.wristDistance = wristDistance;
        let scaleFactor = wristDistance / CONFIG.WRIST_DISTANCE_REF * CONFIG.SCALE_SENSITIVITY;
        scaleFactor = Math.min(scaleFactor, CONFIG.MAX_SCALE_FACTOR);
        scaleFactor = Math.max(scaleFactor, CONFIG.MIN_SCALE_FACTOR);
        state.currentHandSize = scaleFactor;
      }

      updatePalmOrientation(landmarks) {
        const wrist = landmarks[0];
        const middleMCP = landmarks[9];
        state.palmOrientation = {
          x: (middleMCP.x - wrist.x) * window.innerWidth,
          y: (middleMCP.y - wrist.y) * window.innerHeight
        };
      }

      smoothLandmarks(newLandmarks) {
        if (!state.smoothedLandmarks) {
          state.smoothedLandmarks = newLandmarks.map(lm => ({ ...lm }));
          return state.smoothedLandmarks;
        }
        for (let i = 0; i < newLandmarks.length; i++) {
          state.smoothedLandmarks[i].x = this.lerp(state.smoothedLandmarks[i].x, newLandmarks[i].x, CONFIG.SMOOTHING_FACTOR);
          state.smoothedLandmarks[i].y = this.lerp(state.smoothedLandmarks[i].y, newLandmarks[i].y, CONFIG.SMOOTHING_FACTOR);
        }
        return state.smoothedLandmarks;
      }

      lerp(start, end, factor) { return start * (1 - factor) + end * factor; }

      renderAR() {
        if (!state.lastLandmarks) return;
        FINGER_KEYS.forEach((key, index) => {
          const nail = nails[key];
          if (!state.isApplyAll && index !== state.selectedFingerIndex) {
            nail.visible = false;
            return;
          }
          this.updateNailPosition(key);
          nail.visible = true;
        });
        renderer.render(scene, camera);
      }

      updateNailPosition(fingerKey) {
        const landmarks = state.lastLandmarks;
        const nail = nails[fingerKey];
        if (fingerKey === 'thumb') {
          this.updateThumbNailPosition(fingerKey, landmarks);
        } else {
          this.updateFingerNailPosition(fingerKey, landmarks);
        }
        let texture = nailTextures[state.currentDesign];
        if (!texture) {
          const customDesign = state.customDesigns.find(d => d.id === state.currentDesign);
          if (customDesign) texture = customDesign.texture;
        }
        if (texture) {
          nail.material.uniforms.map.value = texture;
          nail.material.needsUpdate = true;
        }
      }

      updateThumbNailPosition(fingerKey, landmarks) {
        const nail = nails[fingerKey];
        const { tip, mcp, ip } = FINGER_INDICES[fingerKey];
        const tipLandmark = landmarks[tip];
        const mcpLandmark = landmarks[mcp];
        const ipLandmark = landmarks[ip];
        const thumbDirection = { x: tipLandmark.x - landmarks[0].x, y: tipLandmark.y - landmarks[0].y };
        const thumbOffset = {
          x: CONFIG.NAIL_OFFSETS.thumb.x - Math.min(Math.hypot(thumbDirection.x, thumbDirection.y) * 5, 0.02),
          y: CONFIG.NAIL_OFFSETS.thumb.y
        };
        const screenX = (tipLandmark.x + thumbOffset.x) * window.innerWidth;
        const screenY = (1 - (tipLandmark.y + thumbOffset.y)) * window.innerHeight;
        const thumbLength = Math.hypot(
          (tipLandmark.x - mcpLandmark.x) * window.innerWidth,
          (tipLandmark.y - mcpLandmark.y) * window.innerHeight
        );
        let nailHeight = thumbLength * CONFIG.NAIL_SCALE_FACTORS.thumb * state.currentHandSize;
        nailHeight = Math.max(CONFIG.MIN_SIZE, Math.min(CONFIG.MAX_SIZE, nailHeight));
        const angle = Math.atan2(tipLandmark.y - ipLandmark.y, tipLandmark.x - ipLandmark.x);
        nail.position.set(screenX - window.innerWidth / 2, screenY - window.innerHeight / 2, 0);
        const aspect = CONFIG.NAIL_ASPECT_RATIOS[fingerKey];
        nail.scale.set(nailHeight * aspect, nailHeight, 1);
        nail.rotation.z = angle;
      }

      updateFingerNailPosition(fingerKey, landmarks) {
        const nail = nails[fingerKey];
        const { tip, pip } = FINGER_INDICES[fingerKey];
        const tipLandmark = landmarks[tip];
        const pipLandmark = landmarks[pip];
        const offset = CONFIG.NAIL_OFFSETS[fingerKey];
        const screenX = (tipLandmark.x + offset.x) * window.innerWidth;
        const screenY = (1 - (tipLandmark.y + offset.y)) * window.innerHeight;
        const fingerLength = Math.hypot(
          (tipLandmark.x - pipLandmark.x) * window.innerWidth,
          (tipLandmark.y - pipLandmark.y) * window.innerHeight
        );
        let nailHeight = fingerLength * CONFIG.NAIL_SCALE_FACTORS[fingerKey] * state.currentHandSize;
        nailHeight = Math.max(CONFIG.MIN_SIZE, Math.min(CONFIG.MAX_SIZE, nailHeight));
        const angle = Math.atan2(tipLandmark.y - pipLandmark.y, tipLandmark.x - pipLandmark.x);
        nail.position.set(screenX - window.innerWidth / 2, screenY - window.innerHeight / 2, 0);
        const aspect = CONFIG.NAIL_ASPECT_RATIOS[fingerKey];
        nail.scale.set(nailHeight * aspect, nailHeight, 1);
        nail.rotation.z = angle;
      }

      hideAllNails() {
        FINGER_KEYS.forEach(key => nails[key].visible = false);
        renderer.render(scene, camera);
      }

      handleCanvasClick(event) {
        if (state.isApplyAll || !state.lastLandmarks) return;
        event.preventDefault();
        const rect = elements.canvas.getBoundingClientRect();
        const x = (event.clientX || event.touches[0].clientX) - rect.left;
        const y = (event.clientY || event.touches[0].clientY) - rect.top;
        state.selectedFingerIndex = this.getClosestFinger(x, y);
      }

      getClosestFinger(touchX, touchY) {
        let minDist = Infinity, closestIndex = -1;
        FINGER_KEYS.forEach((key, index) => {
          const tipIndex = FINGER_INDICES[key].tip;
          const landmark = state.lastLandmarks[tipIndex];
          const x = landmark.x * window.innerWidth;
          const y = (1 - landmark.y) * window.innerHeight;
          const dist = Math.hypot(touchX - x, touchY - y);
          if (dist < minDist && dist < window.innerWidth * 0.1) {
            minDist = dist;
            closestIndex = index;
          }
        });
        return closestIndex;
      }

      toggleLanguage() {
        state.currentLang = state.currentLang === 'en' ? 'uk' : 'en';
        this.updateUI();
        elements.langBtn.textContent = state.currentLang === 'en' ? 'UK' : 'EN';
      }

      setApplyAllMode() {
        state.isApplyAll = true;
        state.selectedFingerIndex = -1;
        elements.applyAllBtn.classList.add('active');
        elements.selectFingerBtn.classList.remove('active');
      }

      setSelectFingerMode() {
        state.isApplyAll = false;
        elements.applyAllBtn.classList.remove('active');
        elements.selectFingerBtn.classList.add('active');
      }

      selectDesign(name) {
        state.currentDesign = name;
        document.querySelectorAll('.design-btn').forEach(btn => {
          btn.classList.toggle('selected', btn.src.includes(`${name}.png`) || btn.dataset.id === name);
        });
        this.triggerConfetti();
      }

      selectMask(maskId, index) {
        state.currentMask = maskId;
        document.querySelectorAll('.mask-btn').forEach((btn, i) => {
          btn.classList.toggle('selected', i === index);
        });
      }

      uploadDesign() {
        elements.designUpload.click();
      }

      handleDesignUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = new Image();
          img.onload = () => {
            const texture = new THREE.CanvasTexture(img);
            texture.wrapS = THREE.ClampToEdgeWrapping;
            texture.wrapT = THREE.ClampToEdgeWrapping;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.format = THREE.RGBAFormat;
            texture.generateMipmaps = false;
            const designId = `custom_${Date.now()}`;
            state.customDesigns.push({
              id: designId,
              url: e.target.result,
              texture: texture
            });
            this.buildDesignUI();
            this.selectDesign(designId);
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
        event.target.value = '';
      }

      triggerConfetti() {
        const rect = elements.designPicker.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;
        for (let i = 0; i < 50; i++) {
          confetti.push(new ConfettiParticle(x + (Math.random() - 0.5) * 100, y));
        }
      }

      updateUI() {
        const t = translations[state.currentLang];
        document.title = t.title;
        elements.loadingText.textContent = t.loading;
        document.querySelector('#loading p').textContent = t.cameraPrompt;
        elements.applyAllBtn.textContent = t.allFingers;
        elements.selectFingerBtn.textContent = t.pickFinger;
        elements.handIndicator.innerHTML = `<span>Hand</span><span>${t.handNotDetected}</span>`;
        elements.cameraIndicator.innerHTML = `<span>Camera</span><span>${t.cameraActive}</span>`;
        elements.langBtn.textContent = state.currentLang === 'en' ? 'UK' : 'EN';
        this.updateSoundButton();
      }

      updateSoundButton() {
        elements.soundBtn.textContent = state.isMuted ? 'Muted' : 'Sound';
      }

      showCameraIndicator() {
        elements.cameraIndicator.classList.add('show');
        setTimeout(() => elements.cameraIndicator.classList.remove('show'), 3000);
      }

      showHandIndicator() { elements.handIndicator.classList.add('show'); }
      hideHandIndicator() { elements.handIndicator.classList.remove('show'); }

      hideLoading() {
        elements.loading.style.display = 'none';
        elements.video.style.display = 'block';
        elements.canvas.style.display = 'block';
      }

      handleResize() {
        if (!camera || !renderer) return;
        camera.left = -window.innerWidth / 2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = -window.innerHeight / 2;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      handleError(error) {
        console.error('App error:', error);
        const t = translations[state.currentLang];
        let message = error.message === 'CAMERA_ERROR' ? t.cameraError : t.arError;
        elements.loading.innerHTML = `
          <div style="color: #ff4757; font-size: 24px; margin-bottom: 20px;">Error</div>
          <div style="color: white; font-size: 18px; margin-bottom: 20px; line-height: 1.4;">${message}</div>
          <button id="errorRetry">${t.retry}</button>
        `;
        elements.loading.style.display = 'flex';
        document.getElementById('errorRetry').addEventListener('click', () => location.reload());
      }

      cleanup() {
        if (state.animationFrameId) cancelAnimationFrame(state.animationFrameId);
        if (elements.video.srcObject) elements.video.srcObject.getTracks().forEach(track => track.stop());
        if (handLandmarker) handLandmarker.close();
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      if (!navigator.onLine) {
        document.getElementById('loading').innerHTML = `
          <div style="color: #ff4757; font-size: 24px;">Offline</div>
          <p style="color: white; max-width: 300px; line-height: 1.4;">This app requires internet to load AR models and designs.</p>
        `;
      } else {
        new NailARApplication();
      }
    });
  </script>
</body>
</html>
